package steps

import (
	"fmt"
	"os"
	"strings"

	"dbca_tui/internal/generator"
	"dbca_tui/internal/model"
	"dbca_tui/internal/ui"
	"dbca_tui/internal/wizard"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

// SummaryStep displays the final summary and generated command
type SummaryStep struct {
	config        *model.DBConfig
	showPasswords bool
	saved         bool
	saveError     string
	focusIndex    int
}

// NewSummaryStep creates a new summary step
func NewSummaryStep() *SummaryStep {
	return &SummaryStep{}
}

// Init initializes the step
func (s *SummaryStep) Init(config *model.DBConfig) tea.Cmd {
	s.config = config
	s.showPasswords = false
	s.saved = false
	s.saveError = ""
	s.focusIndex = 0
	return nil
}

// Update handles messages
func (s *SummaryStep) Update(msg tea.Msg) (wizard.Step, wizard.StepResult, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "esc":
			return s, wizard.StepBack, nil

		case "p", "P":
			s.showPasswords = !s.showPasswords

		case "s", "S":
			s.saveToFile()

		case "g", "G", "enter":
			// Generate command and exit
			if s.focusIndex == 0 {
				return s, wizard.StepPrintAndQuit, nil
			}
			// Handle other focused items
			switch s.focusIndex {
			case 1:
				s.showPasswords = !s.showPasswords
			case 2:
				s.saveToFile()
			case 3:
				return s, wizard.StepQuit, nil
			}

		case "q", "Q":
			return s, wizard.StepQuit, nil

		case "up", "k":
			if s.focusIndex > 0 {
				s.focusIndex--
			}

		case "down", "j":
			if s.focusIndex < 3 {
				s.focusIndex++
			}
		}
	}

	return s, wizard.StepStay, nil
}

func (s *SummaryStep) saveToFile() {
	var filename string
	if s.config.Operation == model.OperationDelete {
		filename = fmt.Sprintf("dbca_delete_%s.sh", s.config.DeleteSID)
	} else {
		filename = fmt.Sprintf("dbca_%s.sh", s.config.SID)
	}

	opType := "Create"
	if s.config.Operation == model.OperationDelete {
		opType = "Delete"
	}

	content := fmt.Sprintf("#!/bin/bash\n# DBCA Silent Mode Command - %s Database\n# Generated by DBCA TUI\n\n", opType)
	content += generator.GenerateCommandWithPasswords(s.config)
	content += "\n"

	err := os.WriteFile(filename, []byte(content), 0600)
	if err != nil {
		s.saveError = fmt.Sprintf("Error saving file: %v", err)
		s.saved = false
	} else {
		s.saved = true
		s.saveError = ""
	}
}

// View renders the step
func (s *SummaryStep) View() string {
	var b strings.Builder

	if s.config.Operation == model.OperationDelete {
		return s.renderDeleteView(&b)
	}
	return s.renderCreateView(&b)
}

func (s *SummaryStep) renderDeleteView(b *strings.Builder) string {
	// Warning for delete
	warningStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#FF5555")).
		Bold(true)
	b.WriteString(warningStyle.Render("WARNING: This will generate a command to DELETE the database!") + "\n\n")

	b.WriteString(ui.SubtitleStyle.Render("Review your deletion settings:") + "\n\n")

	// Summary
	b.WriteString(ui.BoxStyle.Render(s.renderDeleteSummary()) + "\n\n")

	// Generated command preview
	b.WriteString(ui.LabelStyle.Render("Generated DBCA Delete Command (preview):") + "\n")

	var command string
	if s.showPasswords {
		command = generator.GenerateCommandWithPasswords(s.config)
	} else {
		command = generator.GenerateCommand(s.config)
	}
	b.WriteString(ui.CodeBlockStyle.Render(command) + "\n\n")

	// Actions
	s.renderActions(b, fmt.Sprintf("dbca_delete_%s.sh", s.config.DeleteSID))

	return b.String()
}

func (s *SummaryStep) renderCreateView(b *strings.Builder) string {
	b.WriteString(ui.SubtitleStyle.Render("Configuration complete! Review your settings:") + "\n\n")

	// Summary
	b.WriteString(ui.BoxStyle.Render(s.renderCreateSummary()) + "\n\n")

	// Generated command preview
	b.WriteString(ui.LabelStyle.Render("Generated DBCA Command (preview):") + "\n")

	var command string
	if s.showPasswords {
		command = generator.GenerateCommandWithPasswords(s.config)
	} else {
		command = generator.GenerateCommand(s.config)
	}
	b.WriteString(ui.CodeBlockStyle.Render(command) + "\n\n")

	// Actions
	s.renderActions(b, fmt.Sprintf("dbca_%s.sh", s.config.SID))

	return b.String()
}

func (s *SummaryStep) renderActions(b *strings.Builder, filename string) {
	b.WriteString(ui.LabelStyle.Render("Actions:") + "\n\n")

	// Generate and exit (primary action)
	actionStyle := ui.NormalItemStyle
	if s.focusIndex == 0 {
		actionStyle = ui.SelectedItemStyle
	}
	b.WriteString(fmt.Sprintf("  > %s\n", actionStyle.Render("Generate command and exit (g/Enter)")))
	b.WriteString(ui.SubtitleStyle.Render("    Exits the wizard and prints the command to terminal") + "\n\n")

	// Toggle passwords
	actionStyle = ui.NormalItemStyle
	if s.focusIndex == 1 {
		actionStyle = ui.SelectedItemStyle
	}
	checkbox := ui.UncheckedStyle.String()
	if s.showPasswords {
		checkbox = ui.CheckedStyle.String()
	}
	b.WriteString(fmt.Sprintf("  %s %s\n", checkbox, actionStyle.Render("Show passwords in preview (p)")))

	// Save to file
	actionStyle = ui.NormalItemStyle
	if s.focusIndex == 2 {
		actionStyle = ui.SelectedItemStyle
	}
	saveText := fmt.Sprintf("Save to file (s) - %s", filename)
	b.WriteString(fmt.Sprintf("  > %s\n", actionStyle.Render(saveText)))

	if s.saved {
		b.WriteString(ui.SuccessStyle.Render(fmt.Sprintf("    Saved to %s", filename)) + "\n")
	}
	if s.saveError != "" {
		b.WriteString(ui.ErrorStyle.Render("    " + s.saveError) + "\n")
	}

	// Quit without printing
	actionStyle = ui.NormalItemStyle
	if s.focusIndex == 3 {
		actionStyle = ui.SelectedItemStyle
	}
	b.WriteString(fmt.Sprintf("\n  > %s\n", actionStyle.Render("Exit without printing (q)")))

	b.WriteString("\n" + ui.SubtitleStyle.Render("Use arrow keys to navigate, Enter to select"))
}

func (s *SummaryStep) renderDeleteSummary() string {
	var b strings.Builder

	b.WriteString(ui.RenderKeyValue("Operation", "DELETE DATABASE") + "\n")
	b.WriteString(ui.RenderKeyValue("Database SID", s.config.DeleteSID) + "\n")

	forceDelete := "No"
	if s.config.DeleteForce {
		forceDelete = "Yes"
	}
	b.WriteString(ui.RenderKeyValue("Force Delete", forceDelete) + "\n")

	return b.String()
}

func (s *SummaryStep) renderCreateSummary() string {
	var b strings.Builder

	b.WriteString(ui.RenderKeyValue("Operation", "CREATE DATABASE") + "\n")
	b.WriteString(ui.RenderKeyValue("Database Name", s.config.GlobalDBName) + "\n")
	b.WriteString(ui.RenderKeyValue("SID", s.config.SID) + "\n")

	if s.config.CreateAsContainerDB {
		b.WriteString(ui.RenderKeyValue("Container DB", "Yes") + "\n")
		if s.config.NumberOfPDBs > 0 {
			b.WriteString(ui.RenderKeyValue("PDBs", fmt.Sprintf("%d (%s)", s.config.NumberOfPDBs, s.config.PDBName)) + "\n")
		}
	} else {
		b.WriteString(ui.RenderKeyValue("Container DB", "No") + "\n")
	}

	deployType := "Single Instance"
	if s.config.DeploymentType == model.DeploymentRAC {
		deployType = "RAC"
	} else if s.config.DeploymentType == model.DeploymentRACOneNode {
		deployType = "RAC One Node"
	}
	b.WriteString(ui.RenderKeyValue("Deployment", deployType) + "\n")

	if s.config.StorageType == model.StorageTypeASM {
		b.WriteString(ui.RenderKeyValue("Storage", fmt.Sprintf("ASM (%s)", s.config.ASMDiskGroup)) + "\n")
	} else {
		b.WriteString(ui.RenderKeyValue("Storage", "File System") + "\n")
		b.WriteString(ui.RenderKeyValue("Data Files", s.config.DatafileDestination) + "\n")
	}

	b.WriteString(ui.RenderKeyValue("Memory", fmt.Sprintf("%d MB", s.config.TotalMemory)) + "\n")
	b.WriteString(ui.RenderKeyValue("Character Set", s.config.CharacterSet) + "\n")

	// Archive log mode
	archiveMode := "NOARCHIVELOG"
	if s.config.EnableArchiveLog {
		archiveMode = "ARCHIVELOG"
	}
	b.WriteString(ui.RenderKeyValue("Archive Mode", archiveMode) + "\n")

	return b.String()
}

// Title returns the step title
func (s *SummaryStep) Title() string {
	if s.config != nil && s.config.Operation == model.OperationDelete {
		return "Delete Database - Confirm"
	}
	return "Summary & Command Generation"
}

// Apply applies the step's changes to the config
func (s *SummaryStep) Apply(config *model.DBConfig) {
	// Nothing to apply - this is the final step
}

// ShouldSkip returns whether this step should be skipped
func (s *SummaryStep) ShouldSkip(config *model.DBConfig) bool {
	return false
}
